##
# overriding functions
#
# Improves the man
man ()
{
  /usr/bin/man "$@" 2> /dev/null || /usr/bin/man "$MYMANUAL"/"$@" 2> /dev/null || less -x 2 "$MYHELP"/man_$@".txt 2> /dev/null || /usr/bin/man "$MYMANUAL"/$(echo "$@" | tr -d  "=") 2> /dev/null || less -x 2 "$MYHELP"/man_""$(echo "$@" | tr -d  '=')".txt 2> /dev/null || cowsay "No trace of manual page" 2> /dev/null || echoerr "No trace of manual page";
}

# Change the cat to refuse to work without treats
tac ()
{
    if [ "$1" != "+treats" ]; then
        echoerr "meow" && return 1;
    else
        for i in "$@";
        do
            if [ "$i" != "+treats" ]; then
                /usr/bin/tac "$i";
            fi;
        done;
    fi
}

# usefull functions
#
# Defines a error echo function
echoerr ()
{
  echo -e "$RED$@$NC" 1>&2;
}

# used to define the PS1 local
DEFAULT_COLOR=$CYAN;
default_color=$cyan;
atom_colors_compability="yes";
deflocal ()
{
  # BRANCH=$(git branch -vv 2> /dev/null | grep "*" | cut -d " " -f 2);
  BRANCH=$(getbranch no);
  if [ "$BRANCH" != "" ]; then
    REPO=$(basename $(git rev-parse --show-toplevel));
    LOCAL=$(pwd -L);
    SUBDIR=$(echo "${LOCAL##*$REPO}");
    FULLDIR=$REPO$SUBDIR;
    EXTRA=$(getgitsymbol "$BRANCH" 2> /dev/null);
    [ -n "$EXTRA" ] && EXTRA=" $EXTRA";
    BRANCH_WITH_COLOR=$(getbranch "$atom_colors_compability");
    # echo -e '['"$cyan""$FULLDIR""$NC"'] ['"$CYAN""$BRANCH""$EXTRA""$NC"']';
    echo -e '['"$default_color""$FULLDIR""$NC"'] ['"$BRANCH_WITH_COLOR""$default_color""$EXTRA""$NC"']';
  else
    PWD=$(pwd | sed "s|^$HOME|~|");
    echo -e '['"$DEFAULT_COLOR""$PWD""$NC"']';
  fi
}

# On branches, this will return the branch name
# On non-branches, this will return nothing
getbranch ()
{
  ATOM_COLORS="$1";
  EXTRA="$2";
  #ref="$(git symbolic-ref HEAD 2> /dev/null | grep 'refs/heads' | sed -e 's/refs\/heads\///')"
  ref=`git branch -vv 2> /dev/null | grep "*" | cut -d " " -f 2`;
  if [ "$ref" != "" ]; then
    if [ "$ATOM_COLORS" = "yes" ];then
      if [ -r "$HOME/.atom/styles.less" ];then
        echo `get_color_from_file $HOME/.atom/styles.less "$ref" "$EXTRA"`;
      fi
    else
      echo "$ref";
    fi
  else
    echo "";
  fi
}

# Defines the color for the branch
# as the same color used on Atom
# by the extension tree-view-git-status
get_color_from_file ()
{
    COLORS_FROM_FILE="";
    BRANCHES_FROM_FILE="";
    COLOR_LINE="";
    filename="$1";
    p_branch="$2";
    p_extra="$3";
    while read -r l; do
        line="$l";
        if [ "$COLOR_LINE" != "" ]; then
            new_color=`echo "$line" | sed "s/color: //" | tr -d ";"`;
            COLORS_FROM_FILE="$COLORS_FROM_FILE $new_color";
            COLOR_LINE="";
        fi;
        if [[ "$line" = ".tree-view-git-status.git-branch-"* ]]; then
            new_branch=`echo "$line" | sed "s/.tree-view-git-status.git-branch-//" | cut -d " " -f 1`;
            BRANCHES_FROM_FILE="$BRANCHES_FROM_FILE $new_branch";
            COLOR_LINE="yes";
        fi;
    done < "$filename";
    if [ "$COLORS_FROM_FILE" != "" ]; then
        # echo -e "$BLUE $BRANCHES_FROM_FILE $NC" > /tmp/BRANCHES;
        # echo -e "$BLUE $COLORS_FROM_FILE $NC" > /tmp/COLORS;
        i=1;
        color="";
        for branch in $BRANCHES_FROM_FILE;
        do
            if [ "$branch" = "$p_branch" ]; then
                color=`echo "$COLORS_FROM_FILE" | xargs | cut -d " " -f $i`;
                # echo -e "$BLUE yes $NC pls print branch $branch on color $color and number $i" > /tmp/DEBUG;
                break;
            # else
                # echo -e "colors -$COLORS_FROM_FILE - $RED not $NC pls print branch $branch on color $color and number $i" > /tmp/DEBUG_NOT;
            fi;
            ((i++));
        done;
        if [ -n $color ]; then
            var=`echo $color`;
            # echo "@@$BRANCH_WITH_EXTRA@@" > /tmp/BRANCH_WITH_EXTRA
            echo -e "${!var}""$p_branch""$p_extra""$NC";
        fi;
    else
        echo -e "$DEFAULT_COLOR""$p_branch""$p_extra""$NC";
    fi
}

# Prints the symbol
# $1 -- must be the branch
getgitsymbol ()
{
  [ -n "$1" ] || ( echoerr "getgitsymbol: missing branch" && return 1);
  [ "$2" == "@" ] && echo "Before unstaged";
  UNSTAGED=$(unstaged);
  [ "$2" == "@" ] && echo "Before ahead";
  AHEAD=$(ahead $1);
  [ "$2" == "@" ] && echo "Before behind";
  # BEHIND=$(behind $1);
  BEHIND=$(behind $1);
  [ "$2" == "@" ] && echo "After behind";
  echo -n "$UNSTAGED";
  ( [ -n "$UNSTAGED" ] && [ -n "$AHEAD" ] ) && echo -n " " ;
  echo -n "$AHEAD";
  ( ( [ -n "$UNSTAGED" ] || [ -n "$AHEAD" ] ) && [ -n "$BEHIND" ] ) && echo -n " " ;
  echo -n "$BEHIND";
}

# Return 1 if have modifications not staged for commits
# $1 -- @ if you want debug
unstaged_symbol='*';
unstaged ()
{
  # If the git status has *any* changes (e.g. dirty), echo our character
  INFO=$(git status --porcelain 2> /dev/null);
  [ "$1" == "@" ] && echo "$INFO";
  if [ -n "$INFO" ]; then
    echo "$unstaged_symbol";
  fi
}

# Prints 1 if have commits not send to server
# $1 -- must be the branch
ahead_symbol="↑";
ahead ()
{
  [ -n "$1" ] || ( echoerr "ahead: missing branch" && return 1);
  INFO=$(git rev-list --left-right --count origin/$1...HEAD | cut -f 2);
  [ "$2" == "@" ] && echo "$INFO";
  if [[ -n "$INFO" && $INFO -gt 0 ]]; then
    echo "$ahead_symbol""$INFO";
  fi
}

# Prints 1 if have changes not send pulle from the server
# $1 -- must be the branch
behind_symbol="↓";
behind ()
{
  TMPDIR=/tmp;
  [ -n "$1" ] || ( echoerr "behind: missing branch" && return 1);
  INFO=$(git rev-list --left-right --count origin/$1...HEAD | cut -f 1);
  [ "$2" == "@" ] && echo "$INFO";
  if [[ -n "$INFO" && $INFO -gt 0 ]]; then
    echo "$behind_symbol""$INFO";
  fi
  unset BEHIND;
}

# used to define the host color/name
defhost ()
{
  if [ "$(hostname)"  = "MORDOR" ]; then
    echo -e "$GREEN""$(hostname)""$NC";
  elif [[ "$(hostname)"  = "lups"* ]]; then
    echo -e "$PURPLE""$(hostname)""$NC";
  else
    echo -e "$PURPLE""$(hostname)""$NC";
  fi
}

# used to define the host color/name
defuser ()
{
  if ([ "$(whoami)"  = "lebretana" ] || [ "$(whoami)"  = "lucasbretana" ] || [ "$(whoami)"  = "lucas" ]) ; then
    echo -e "$green""$(whoami)""$NC";
  elif [[ "$(whoami)"  = "root"* ]]; then
    echo -e "$red""$(whoami)""$NC";
  else
    echo -e "$cyan""$(whoami)""$NC";
  fi
}

# print color I know
colors ()
{
  string="Hello World";
  if [ -n "$1" ]; then
    string=$1;
  fi
  echo -e "grey: $grey""$string""$NC";
  echo -e "GREY: $GREY""$string""$NC";
  echo -e "red: $red""$string""$NC";
  echo -e "RED: $RED""$string""$NC";
  echo -e "green: $green""$string""$NC";
  echo -e "GREEN: $GREEN""$string""$NC";
  echo -e "yellow: $yellow""$string""$NC";
  echo -e "YELLOW: $YELLOW""$string""$NC";
  echo -e "purple: $purple""$string""$NC";
  echo -e "PURPLE: $PURPLE""$string""$NC";
  echo -e "white: $white""$string""$NC";
  echo -e "WHITE: $WHITE""$string""$NC";
  echo -e "blue: $blue""$string""$NC";
  echo -e "BLUE: $BLUE""$string""$NC";
  echo -e "cyan: $cyan""$string""$NC";
  echo -e "CYAN: $CYAN""$string""$NC";
}

# Uses the cllinsdictionary to define a word, and shows only the part
# that is relevant for the context
define ()
{
  curl -s "https://www.collinsdictionary.com/dictionary/english/$*" | sed -n '/class="def"/p' | awk '{gsub(/.*<span class="def">|<\/span>.*/,"");print}' | sed "s/<[^>]\+>//g";
}

# Used to convert some manual to a PDF file
man2pdf ()
{
  man -t $1 | ps2pdf - > $1.pdf
}

# Changes all leter in string to it's correspondent in upper casae
toup ()
{
  echo $1 | tr '[:lower:]' '[:upper:]'
}

# Changes all leter in string to it's correspondent in lower case
tolow ()
{
  echo $1 | tr '[:upper:]' '[:lower:]'
}

# Flip a coin, faster than Google's
flipacoin ()
{
  [ $[ $RANDOM % 2] == 0 ] && echo "Heads" || echo "Tails";
}

# Gets the weahter from the wttr sie and shows in terminal
# It can be specified witch city you want, the default is Pelotas
getweather ()
{
  if [ -n "$@" ]; then
    curl "http://wttr.in/$@";
  else
    curl "http://wttr.in/Pelotas";
  fi
}

# Check if ONE repositorie needs a commit and/or a pull
cgit ()
{
  if [ -n "$1" ]; then
    cd $1 2> /dev/null || (echoerr "Directory \"$1\" not found!" && return);
    REPO=$(pwd -P);
    BRANCH="master"
    if [ -n "$2" ]; then
      BRANCH=$2;
      git checkout $BRANCH 1> /dev/null 2> /dev/null || (echoerr "Branch \"$BRANCH\" not found" && return);
    fi
    # STATUS=$(git status 2> /dev/null | tr "\n" "+" | grep -v "nothing to commit" | tr "+" "\n");
    STATUS=$(unstaged || ahead $BRANCH);
    if [ -n "$STATUS" ]; then
      echo -e "\n############################################";
      echo "#### On repo: $(basename $(git rev-parse --show-toplevel)) [$REPO :: $BRANCH]";
      echo "It's missing a commit and/or push!";
    fi
    # PULL=$(git pull --dry-run origin $BRANCH  2>&1 1>  /dev/null | grep -iv github | grep -iv branch);
    PULL=$(behind $BRANCH);
    if [ -n "$PULL" ]; then
      echo -e "\n############################################";
      echo "#### On repo: $(basename $(git rev-parse --show-toplevel)) [$REPO :: $BRANCH]";
      echo "It's missing a pull!";
    fi;
  fi;
}

# Check all gits repositories for missing commit/push and pull/fetch
# Uses updategitvar
checkgit ()
{
  if [ -z "$GIT" ]; then
    updategitvar;
  fi;
  if [ -z "$GIT" ]; then
    echoerr "The 'GIT' system variable is not set" && return;
  fi;
  export GIT;

  if [ $# -ge 2 ]; then
    cgit "$@";
    return;
  elif [ -n "$1" ]; then
    cgit $1;
    return;
  fi
  BACK=$(whereami);
  for REPO in $(echo $GIT | tr ":" "\n");
  do
    cd $REPO;
    for BRANCH in $(git branch --list | tr "*" " " | tr "\n" " "); {
      [ "$DEBUG" = "true" ] && echo "Calling cgit with \"$REPO\" and \"$BRANCH\"";
      cgit $REPO $BRANCH;
    }
  done;
  cd $BACK;
}

# Updates the GIT var, than contains all repositories,
# Run after added a new one or remove an old one
# It is used by checkgit function
updategitvar ()
{
  unset GIT ;
  for i in $(find $HOME -name ".git" 2> /dev/null | sed "s/\/.git//g"); {
    if [ -n "$GIT" ]; then
      GIT=$GIT:$i ;
    else
      GIT=$i ;
    fi
  }
  export GIT;
}

# Top 10 CPU and memory eating process
memcpu ()
{
  echo -e "*** Top $RED ten $NC $PURPLE CPU $NC eating process ***"; ps aux | sort -nr -k 3 | head -10;
  echo;echo;
  echo -e "*** Top $RED ten $NC $PURPLE MEMORY $NC eating process ***"; ps aux | sort -nr -k 4 | head -10;
}

# Automatically decompress some know types of files
decompress ()
{
  if [ "$1" = "-bz2" ]; then
    (bunzip2 "$2" && return 0) || (echoerr "bunzip2: error" && return 1);
  elif [ "$1" = "-tar.bz2" ]; then
    (tar -vxjpf "$2" && return 0) || (echoerr "tar: error" && return 1);
  elif [ "$1" = "-tar.gz" ];then
    (tar -vxjpf "$2" && return 0) || (echoerr "tar: error" && return 1);
  elif [ "$1" = "-tgz" ];then
    (tar -vxjpf "$2" && return 0) || (echoerr "tar: error" && return 1);
  elif [ "$1" = "-gz" ];then
    (tar -vxjpf "$2" && return 0) || (echoerr "tar: error" && return 1);
  elif [ "$1" = "-tar" ];then
    (tar xf "$2" && return 0) || (echoerr "tar: error" && return 1);
  elif [ "$1" = "-tar.xz" ];then
    (tar -xf "$2" && return 0) || (echoerr "tar: error" && return 1);
  elif [ "$1" = "-zip" ];then
    (unzip "$2" && return 0) || (echoerr "tar: error" && return 1);
  elif [ "$1" = "-7z" ];then
    (7z x -y "$2" && return 0) || (echoerr "tar: error" && return 1);
  elif [ "$1" = "-rar" ];then
    (unrar "$2" && return 0) || (echoerr "tar: error" && return 1);
  fi

  filename=$(basename "$1");

  case "$filename" in
    *.bz2)     bunzip2 "$1"     || echoerr "bunzip2: error";;
    *.tar.bz2) tar -vxjpf "$1"  || echoerr "tar: error";;
    *.tar.gz)  tar -vzxf "$1"   || echoerr "tar: error";;
    *.tgz)     tar -vzxf "$1"   || echoerr "tar: error";;
    *.gz)      tar -vzxf "$1"   || echoerr "tar: error";;
    *.tar)     tar xf "$1"      || echoerr "tar: error";;
    *.tar.xz)  tar -xf "$1"     || echoerr "tar: error";;
    *.zip)     unzip "$1"       || echoerr "unzip: error";;
    *.7z)      7z x -y "$1"     || echoerr "7z: error";;
    *.rar)     unrar x "$1"     || echoerr "unrar: error";;
    *)         echoerr "decompress: error, unsuported";;
  esac
}
